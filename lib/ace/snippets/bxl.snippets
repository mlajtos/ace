# scope: bxl

# math agent

snippet math.floor
	floor(${1:2.3})

snippet math.ceil
	ceil(${1:2.3})

snippet math.round
	round(${1:2.3})

snippet math.random
	random()

snippet math.randomInt
	random{
		/int = ${1:6};
	}

snippet math.randomLong
	random{
		/long = ${1:6};
	}

# is agent

snippet is.module
	module(${1})

snippet is.subNodes
	subNodes(${1})

snippet is.typeBoolean
	typeBoolean(${1})

snippet is.typeDate
	typeDate(${1})

snippet is.typeDatetime
	typeDatetime(${1})

snippet is.typeDouble
	typeDouble(${1})

snippet is.typeDecimal
	typeDecimal(${1})

snippet is.typeInt
	typeInt(${1})

snippet is.typeLong
	typeLong(${1})

snippet is.typeNode
	typeNode(${1})

snippet is.typeString
	typeString(${1})

snippet is.typeTime
	typeTime(${1})

snippet is.typeValueNN
	typeValueNN(${1})

snippet is.valueNE
	valueNE(${1})

snippet is.valueDatetime
	valueDatetime(${1})

snippet is.valueDate
	valueDate(${1})

snippet is.valueTime
	valueTime(${1})

snippet is.valueBoolean
	valueBoolean(${1})

snippet is.valueDouble
	valueDouble(${1})

snippet is.valueDoubleNZ
	valueDoubleNZ(${1})

snippet is.valueDecimal
	valueDecimal(${1})

snippet is.valueInt
	valueInt(${1})

snippet is.valueIntNZ
	valueIntNZ(${1})

snippet is.valueLong
	valueLong(${1})

snippet is.valuePathNE
	valuePathNE(${1})

snippet is.valueString
	valueString(${1})

snippet is.valueStringNE
	valueStringNE(${1})

# path agent

snippet path.items
	items(${1})

snippet path.join
	join(${1})

snippet path.key
	key(${1})

snippet path.length
	length(${1})

snippet path.pathToTreeFocus
	pathToTreeFocus(${1})

snippet path.treeFocusToPath
	treeFocusToPath(${1})

snippet path.split
	split{
		/path = ${1};
		/key = ${2};
	}

snippet path.keyAt
	keyAt{
		/path = ${1};
		/index = ${2};
	}

snippet path.keyLast
	keyLast(${1})

snippet path.subPath
	subPath{
		/path = ${1};
		/beginIndex = ${2};
		/endIndex = ${3};
	}

snippet path.tail
	tail(${1})

snippet path.val
	val(${1})

snippet path.keyDelete
	keyDelete{
		/path = ${1};
		/key = ${2};
	}

# date agent

snippet date.add
	add{
		/datetime = ${1};
		/year = ${2};
		/month = ${3};
		/day = ${4};
		/hour = ${5};
		/minute = ${6};
		/second = ${7};
	}

snippet date.dateToStruct
	dateToStruct(${1})

snippet date.datetimeToStruct
	datetimeToStruct(${1})

snippet date.now
	now()

snippet date.parseDatetime
	parseDatetime(${1})

snippet date.parseDate
	parseDate(${1})

snippet date.parseTime
	parseTime(${1})

# tree agent

snippet tree.add
	add{
		/tree = ${1};
		/add = ${2};
	}

snippet tree.count
	count(${1})

snippet tree.dumpToBxl
	dumpToBxl(${1})

snippet tree.dumpToString
	dumpToString(${1})

snippet tree.keyDelete
	keyDelete{
		/tree = ${1};
		/key = ${2};
	}

snippet tree.keyFirst
	keyFirst(${1})

snippet tree.keyLast
	keyLast(${1})

snippet tree.keyMoveDown
	keyMoveDown{
		/tree = ${1};
		/key = ${2};
		/cycle = true;
	}

snippet tree.keyMoveUp
	keyMoveUp{
		/tree = ${1};
		/key = ${2};
		/cycle = true;
	}

snippet tree.keyNext
	keyNext{
		/tree = ${1};
		/key = ${2};
		/cycle = true;
	}

snippet tree.keyPos
	keyPos{ 
		/tree = ${1};
		/key = ${2};
	}

snippet tree.keysDelete
	keysDelete{
		/tree = ${1};
		/keys{
			${2}
		};
	}

snippet tree.pathDelete
	pathDelete{
		/tree = ${1};
		/path = ${2};
	}

snippet tree.reverse
	reverse(${1});

snippet tree.subtree
	subtree{
		/tree = ${1};
		/beginIndex = ${2};
		/endIndex = ${3};
	}

snippet tree.keyInsert
	keyInsert{
		/tree = ${1};
		/key = ${2};
		/addTree = ${3};
		/afterKey = ${4};
	}

# str agent

snippet str.base64decode
	base64decode(${1:"QlhM"})

snippet str.base64encode
	base64encode(${1:"Hello World!"})

snippet str.contains
	contains{
		/string = ${1:"hello world"};
		/substring = ${2:"ello"};
		/ignoreCase = true;
	}

snippet str.endsWith
	endsWith{
		/string = ${1:"Hello"};
		/suffix= ${2:"lo"};
	}

snippet str.extractDiacritics
	extractDiacritics(${1:"héľĺó wôřlď"})

snippet str.format
	format{
		/string = ${1:"Hello %%name%%"};
		/params{
			${2:/name = "World"}
		};
	}

snippet str.find
	find{ 
		/string = ${1:"hello world"}; 
		/regex = ${2:"[a-z]"}; 
	}

snippet str.hashMD5
	hashMD5(${1:"Hello World"})

snippet str.hashSHA1
	hashSHA1(${1:"Hello World"})

snippet str.htmlEncode
	htmlEncode(${1})

snippet str.initCap
	initCap(${1})

snippet str.join
	join{
		/strings = ${1};
		/delimiter = ${2};
	}

snippet str.length
	length(${1:"Hello World"})

snippet str.justify
	justify{
		/string = ${1};
		/length = ${2};
		/char = ${3};
		/type/center = ${4:true};
	}

snippet str.replace
	replace{
		/string = ${1:"Hello World"};
		/regex = ${3:"World"};
		/replacement = ${2:"BXL"};
	}

snippet str.split
	split{
		/string = ${1:"Hello World"};
		/regex = ${2:" "};
	}

snippet str.replaceParams
	replaceParams{
		/string = ${1:"Hello %%param%%"};
		/params{
			/${2:param} = ${3:"world"};
		};
	}

snippet str.substring
	substring{
		/string = ${1:"Hello World"};
		/beginIndex = ${2:0};
		/endIndex = ${3:4};
	}

snippet str.toLowerCase
	toLowerCase(${1:"HELLO WORLD"})

snippet str.toUpperCase
	toUpperCase(${1:"hello world"})

snippet str.trim
	trim(${1:"   hello world   "})

snippet str.startsWith
	startsWith{
		/string = ${1:"Hello World"};
		/prefix= ${2:"Hell"};
	}

# server agent

snippet server.getParam
	getParam(${1})

snippet server.session
	session.read{
		/context[${1:in/urlContext}] = null;
	}

snippet server.session.write
	session.write{
		/context[${1:in/urlContext}] = null;
		/tree = ${2:tmp/tree};
	}

# lang agent

snippet java
	java{
		/class = "${1:sk.jumpsoft.blox.extension.ExtensionPackage.ExtensionClass}";
		/input{
			/parameter = ${2:"value"};
		};
	}

# ide agent

snippet ide.createInstance
	createInstance{
		/typePath${1:app/meh} = null;
		/config = tmp/config; // optional
	}

snippet ide.getConfigType
	getConfigType(${1:tmp/config})

snippet ide.getModuleType
	getModuleType(${1:tmp/config})

snippet ide.isNewIde
	isNewIde()

snippet ide.moduleInstanceOfPath
	moduleInstanceOfPath{
		/module = ${1:tmp/module};
		/parent = ${2:tmp/parent};
	}

snippet ide.moduleTypeOfPath
	moduleTypeOfPath{
		/module = ${1:tmp/module};
		/typePath = ${2:tmp/typePath};
	}

snippet ide.pathInstanceOfPath
	pathInstanceOfPath{
		/module = ${1:tmp/module};
		/parent = ${2:tmp/parent};
	}

snippet ide.registerCode
	registerCode{
		/app = tmp/app;
		/lib = tmp/lib; // only one
	}


# if else
snippet ifelse
	if (${1:true}) {
		${2}
	} else {
		${0}
	}

# for
snippet for
	for (${1:in}) {
		${2:out}[forkey] = forval;
	}

# while
snippet while
	${1:tmp/i} = 0;
	while (${1} < ${2:10}) {
		${3:// code}
		${1} = ${1} + 1;
	}

snippet tryCatch
	try{
	  throw/${1:exception}{
	    /message = "Additional message";
	  };
	} catch/$1 {
	  log(loc/message);
	}

snippet switch
	switch(${1:tmp/greeting}) {
	  case "${2:hello}":
	    ${3:// code}
	    break;
	  default:
	  	${4:// code}
	  	break;
	}

# module operation call
snippet $
	\$${1:module}.${2:operation}{
		${3}
	};

snippet _formMessages
	/messsages[]{
		/type/${1:warning} = null;
		/message = ${2:"Message goes here."};
		/reasons[]{
			/message = ${3:"Optional reason goes here."}
		};
	}

snippet _dataConditions
	/conds[]{
		/name = ${1:"name"};
		/condType/${2:equal} = null;
		/valueType/${3:string} = null;
		/value = ${4:"hello world"};
	};

snippet _dataOrders
	/orders[]{
		/name = ${1:"name"};
		/orderType/desc = true;
	};

snippet _dataRange
	/range{
		/countAll = false;
	};

guard tmp/listOutput\s*
trigger =\s*
snippet _lO
	= \$${1:tmp/datatype}.list{
		${2:_dataRange}
		${3:_dataConditions}
		${4:_dataOrders}
	};

	if (!tmp/listOutput/ok) {
		warning("Cannot perform \"list\" operation on datatype.");
		return;
	}

guard tmp/addOutput\s*
trigger =\s*
snippet _aO
	= \$${1:tmp/datatype}.add{
		/addID = ${2:23};
		/addData = ${3:tmp/data};
		/addOptions/canUpdateRecord = null;
	};

	if (!tmp/addOutput/ok) {
		warning("Cannot perform \"add\" operation on datatype.");
		return;
	}

guard tmp/updateOutput\s*
trigger =\s*
snippet _uO
	= \$${1:tmp/datatype}.update{
		/updateID = ${2:23};
		/updateData = ${3:tmp/data};
		/updateOptions/canNotExist/canAddRecord = null;
		${4:_dataConditions}
	};

	if (!tmp/updateOutput/ok) {
		warning("Cannot perform \"update\" operation on datatype.");
		return;
	}

guard tmp/deleteOutput\s*
trigger =\s*
snippet _dO
	= \$${1:tmp/datatype}.delete{
		/deleteID = ${2:23};
		/deleteOptions/canNotExist = null;
		${4:_dataConditions}
	};

	if (!tmp/deleteOutput/ok) {
		warning("Cannot perform \"delete\" operation on datatype.");
		return;
	}

guard tmp/readOutput\s*
trigger =\s*
snippet _rO
	= \$${1:tmp/datatype}.read{
		/readID = ${2:23};
		/readOptions/canNotExist = null;
		${4:_dataConditions}
	};

	if (!tmp/readOutput/ok) {
		warning("Cannot perform \"read\" operation on datatype.");
		return;
	}